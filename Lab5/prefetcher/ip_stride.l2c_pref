//
// From Data Prefetching Championship Simulator 2
// Seth Pugsley, seth.h.pugsley@intel.com
//

/*

  This file describes an Instruction Pointer-based (Program Counter-based) stride prefetcher.  
  The prefetcher detects stride patterns coming from the same IP, and then 
  prefetches additional cache lines.

  Prefetches are issued into the L2 or LLC depending on L2 MSHR occupancy.

 */

#include "cache.h"

#define IP_TRACKER_L2C_COUNT 1024
#define PREFETCH_DEGREE_L2C 3

// threshold for throttling
#define THRESHOLD_L2C 0.3

// lower limit on degree of prefetch 
#define MIN_DEGREE_L2C 3

// upper limit on degree of prefetch
#define MAX_DEGREE_L2C 10

// Prefetcher table class

class IP_TRACKER_L2C {
  public:
    // the IP we're tracking
    uint64_t ip;

    // the last address accessed by this IP
    uint64_t last_cl_addr;

    // the stride between the last two addresses accessed by this IP
    int64_t last_stride;

    // use LRU to evict old IP trackers_l2c
    uint32_t lru;

    // number of prefetch requests
    uint64_t count_requests;

    // number of useful prefetches
    uint64_t count_useful;

    // prefetch degree
    uint32_t degree;

// constructor for initialisation
    IP_TRACKER_L2C () {
        ip = 0;
        last_cl_addr = 0;
        last_stride = 0;
        lru = 0;
        count_requests = 0;
        count_useful = 0;
        degree = PREFETCH_DEGREE_L2C;
    };
};

IP_TRACKER_L2C trackers_l2c[IP_TRACKER_L2C_COUNT];

// function to implement throttling
void l2c_prefetch_throttle(int index);

// function to update useful prefetches
void l2c_update_accuracy(uint64_t ip, uint8_t prefetch);

void CACHE::l2c_prefetcher_initialize() 
{
    cout << "CPU " << cpu << " L2C IP-based stride prefetcher" << endl;
    for (int i=0; i<IP_TRACKER_L2C_COUNT; i++)
        trackers_l2c[i].lru = i;
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in)
{
    uint32_t set;
    int way;

    // check for a tracker hit
    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

    if(cache_hit) {
        set = get_set(cl_addr);
        way = get_way(cl_addr,set);
        l2c_update_accuracy(block[set][way].ip,block[set][way].prefetch);
    }



    int index = -1;
    for (index=0; index<IP_TRACKER_L2C_COUNT; index++) {
        if (trackers_l2c[index].ip == ip) {
            break;
        }
    }

    // this is a new IP that doesn't have a tracker yet, so allocate one
    if (index == IP_TRACKER_L2C_COUNT) {

        for (index=0; index<IP_TRACKER_L2C_COUNT; index++) {
            if (trackers_l2c[index].lru == (IP_TRACKER_L2C_COUNT-1))
                break;
        }

        trackers_l2c[index].ip = ip;
        trackers_l2c[index].last_cl_addr = cl_addr;
        trackers_l2c[index].last_stride = 0;

        //cout << "[IP_STRIDE] MISS index: " << index << " lru: " << trackers_l2c[index].lru << " ip: " << hex << ip << " cl_addr: " << cl_addr << dec << endl;

        for (int i=0; i<IP_TRACKER_L2C_COUNT; i++) {
            if (trackers_l2c[i].lru < trackers_l2c[index].lru)
                trackers_l2c[i].lru++;
        }
        trackers_l2c[index].lru = 0;

        return metadata_in;
    }

    // sanity check
    // at this point we should know a matching tracker index
    if (index == -1)
        assert(0);

    // calculate the stride between the current address and the last address
    // this bit appears overly complicated because we're calculating
    // differences between unsigned address variables
    int64_t stride = 0;
    if (cl_addr > trackers_l2c[index].last_cl_addr)
        stride = cl_addr - trackers_l2c[index].last_cl_addr;
    else {
        stride = trackers_l2c[index].last_cl_addr - cl_addr;
        stride *= -1;
    }

    //cout << "[IP_STRIDE] HIT  index: " << index << " lru: " << trackers_l2c[index].lru << " ip: " << hex << ip << " cl_addr: " << cl_addr << dec << " stride: " << stride << endl;

    // don't do anything if we somehow saw the same address twice in a row
    if (stride == 0)
        return metadata_in;

    // only do any prefetching if there's a pattern of seeing the same
    // stride more than once
    if (stride == trackers_l2c[index].last_stride) {
        // do throttling 
        l2c_prefetch_throttle(index);

        // do some prefetching
        for (int i=0; i<trackers_l2c[index].degree; i++) {
            uint64_t pf_address = (cl_addr + (stride*(i+1))) << LOG2_BLOCK_SIZE;

            // only issue a prefetch if the prefetch address is in the same 4 KB page 
            // as the current demand access address
            if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                break;

            // check the MSHR occupancy to decide if we're going to prefetch to the L2 or LLC
            if (MSHR.occupancy < (MSHR.SIZE>>1)) {
                trackers_l2c[index].count_requests += prefetch_line(ip, addr, pf_address, FILL_L2, 0);
            }
            else
	            prefetch_line(ip, addr, pf_address, FILL_LLC, 0);
        }
    }

    trackers_l2c[index].last_cl_addr = cl_addr;
    trackers_l2c[index].last_stride = stride;

    for (int i=0; i<IP_TRACKER_L2C_COUNT; i++) {
        if (trackers_l2c[i].lru < trackers_l2c[index].lru)
            trackers_l2c[i].lru++;
    }
    trackers_l2c[index].lru = 0;

    return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
  return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " L2C PC-based stride prefetcher final stats" << endl;
}


void l2c_prefetch_throttle(int index)
{
    // if fraction of total requests which were useful are greater than the threshold value, increment the prefetch degree
    if(trackers_l2c[index].count_useful > trackers_l2c[index].count_requests*THRESHOLD_L2C){
        trackers_l2c[index].degree ++;
    }

    // if fraction of total requests which were useful are lesser than the threshold value, decrement the prefetch degree
    else {
        trackers_l2c[index].degree--;
    }

    // clip prefetch degree to a set minimum limit if less than it
    if(trackers_l2c[index].degree < MIN_DEGREE_L2C) {
        trackers_l2c[index].degree = MIN_DEGREE_L2C;
    }

    // clip prefetch degree to a set maximum limit if greater than it
    if(trackers_l2c[index].degree > MAX_DEGREE_L2C) {
        trackers_l2c[index].degree = MAX_DEGREE_L2C;
    }
        
}

void l2c_update_accuracy(uint64_t ip, uint8_t prefetch)
{
    // check prefetch bit and return if set to false
    if(!prefetch){
        return;
    }

    // if prefetch bit is set to true, iterate through trackers and count the number of useful prefetches by comparing the ip
    for (int index=0; index<IP_TRACKER_L2C_COUNT; index++) {
        if(trackers_l2c[index].ip == ip){
            trackers_l2c[index].count_useful++; 
        }  
    }
}